<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Verisense Sync ‚Äì Debug + Payload Index</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    button { padding: 10px 20px; margin: 8px; }
    pre { background: #111; color: #0f0; padding: 10px; height: 350px; overflow-y: auto; font-size: 14px; }
    #progressBox { background:#333; width:100%; height:20px; border-radius:4px; overflow:hidden; margin-top:10px; }
    #progressFill { background:#0f0; width:0%; height:100%; }
  </style>
</head>
<body>

<h2>Verisense Full Sync (Debug Mode)</h2>

<button id="connectBtn">Connect</button>
<button id="syncBtn" disabled>Start Sync</button>
<button id="stopBtn" disabled>Stop &amp; Save BIN</button>

<div id="progressBox"><div id="progressFill"></div></div>
<p><b>Total Bytes:</b> <span id="byteCount">0</span></p>

<pre id="log"></pre>

<script>
/* ---------------------------------------------------------
   CONSTANTS / PROTOCOL
--------------------------------------------------------- */
const DATA_HEADER       = 0x32;                 // Logged data message
const DATA_END_HEADER   = 0x42;                 // End-of-sync marker
const READ_DATA_REQUEST = new Uint8Array([0x12, 0x00, 0x00]);
const DATA_ACK          = new Uint8Array([0x82, 0x00, 0x00]);
const DATA_NACK         = new Uint8Array([0x72, 0x00, 0x00]); // matches C# dataNACK

/* ---------------------------------------------------------
   GLOBALS
--------------------------------------------------------- */
let port, reader, writer;
let keepReading = false;

let rxBuffer = [];
let fileChunks = [];        // PAYLOAD BYTES ONLY
let totalBytes = 0;

let currentMsg = null;

let lastTs = performance.now();

/* State machine / watchdog */
let lastRxTime = performance.now();
const ReplyType = {
  NONE: 0,
  ACK: 1,
  NACK: 2
};
let lastReplySent = ReplyType.NONE;
let watchdogId = null;

/* For restart-on-done logic */
let readRestartCount = 0;
const MAX_READ_RESTARTS = 3;

/* ---------------------------------------------------------
   DEBUG (bounded)
--------------------------------------------------------- */
const MAX_LOG_LINES = 2000;
function debug(msg) {
  const now = performance.now();
  const delta = (now - lastTs).toFixed(2);
  lastTs = now;

  const el = document.getElementById("log");
  el.textContent += `[+${delta}ms] ${msg}\n`;

  // Trim log to last N lines to avoid DOM bloat
  const lines = el.textContent.split("\n");
  if (lines.length > MAX_LOG_LINES) {
    el.textContent = lines.slice(lines.length - MAX_LOG_LINES).join("\n");
  }

  el.scrollTop = el.scrollHeight;
}

/* ---------------------------------------------------------
   THROUGHPUT
--------------------------------------------------------- */
let lastPayloadTime = performance.now();
let throughputAvg = 0;

function reportThroughput(payloadLength) {
  const now = performance.now();
  const dt = (now - lastPayloadTime) / 1000;   // seconds
  lastPayloadTime = now;

  if (dt <= 0) return;

  const kb = payloadLength / 1024;
  const kbps = kb / dt;                        // instantaneous KB/s

  // simple moving average
  throughputAvg = throughputAvg === 0 ? kbps : (throughputAvg * 0.7 + kbps * 0.3);

  debug(
    `üìä Throughput: ${kbps.toFixed(2)} KB/s (avg ${throughputAvg.toFixed(2)} KB/s)`
  );
}

/* ---------------------------------------------------------
   ACK / NACK / REQUEST helpers
--------------------------------------------------------- */
function sendAck(payloadIndex) {
  if (!writer) return;
  writer.write(DATA_ACK).then(() => {
    lastReplySent = ReplyType.ACK;
    debug(`‚¨Ö ACK sent for payloadIndex=${payloadIndex}`);
  }).catch(err => {
    debug(`‚ùå ACK send failed: ${err}`);
  });
}

function sendNack() {
  if (!writer) return;
  writer.write(DATA_NACK).then(() => {
    lastReplySent = ReplyType.NACK;
    debug("‚¨Ö NACK sent (watchdog)");
  }).catch(err => {
    debug(`‚ùå NACK send failed: ${err}`);
  });
}

function sendReadDataRequest() {
  if (!writer) return;
  writer.write(READ_DATA_REQUEST).then(() => {
    // In C# this corresponds to LastDataTransferReplySent = NONE
    lastReplySent = ReplyType.NONE;
    debug("‚û° ReadDataRequest sent (watchdog or start)");
  }).catch(err => {
    debug(`‚ùå ReadDataRequest send failed: ${err}`);
  });
}

/* ---------------------------------------------------------
   WATCHDOG ‚Äì C#-style ProcessDataTimeout equivalent
--------------------------------------------------------- */
function startWatchdog() {
  if (watchdogId) clearInterval(watchdogId);

  watchdogId = setInterval(() => {
    if (!keepReading) return;

    const now = performance.now();
    const silenceMs = now - lastRxTime;

    // If we've had no data for > 5 seconds, emulate ProcessDataTimeout
    if (silenceMs > 1500) {
      debug(`‚ö†Ô∏è No data for ${silenceMs.toFixed(0)} ms ‚Äî watchdog timeout`);

      if (lastReplySent === ReplyType.NONE) {
        // C# case: LastDataTransferReplySent == NONE ‚Üí resend ReadDataRequest
        debug("‚ö†Ô∏è Watchdog: no prior ACK/NACK, resending ReadDataRequest");
        sendReadDataRequest();
      } else {
        // Mid-sync stall ‚Üí send NACK to request resend
        debug("‚ö†Ô∏è Watchdog: mid-sync stall, sending NACK");
        sendNack();
      }
    }
  }, 1000);
}

function stopWatchdog() {
  if (watchdogId) {
    clearInterval(watchdogId);
    watchdogId = null;
  }
}

/* ---------------------------------------------------------
   PACKETIZER
--------------------------------------------------------- */
function feedBytesIntoPacketizer(bytes) {
  if (!bytes || bytes.length === 0) return;

  for (let b of bytes) rxBuffer.push(b);

  if (rxBuffer.length > 500000) {
    debug("‚ùå Buffer overflow ‚Äî resetting");
    rxBuffer = [];
    currentMsg = null;
    return;
  }

  while (rxBuffer.length >= 3) {

    /* --- EOS 0x42 00 00 --- */
    if (rxBuffer[0] === DATA_END_HEADER) {
      if (rxBuffer.length < 3) return;
      if (rxBuffer[1] === 0x00 && rxBuffer[2] === 0x00) {
        debug("üîö EOS received");
        rxBuffer.splice(0, 3);
        handleEndOfSync();
        return;
      } else {
        rxBuffer.shift();
        continue;
      }
    }

    /* --- MESSAGE HEADER 0x32 --- */
    if (!currentMsg) {
      const cmd = rxBuffer[0];
      if (cmd !== DATA_HEADER) {
        rxBuffer.shift();
        continue;
      }

      const lenLo = rxBuffer[1];
      const lenHi = rxBuffer[2];
      const expectedLen = (lenHi << 8) | lenLo;

      if (expectedLen <= 0 || expectedLen > 60000) {
        rxBuffer.shift();
        continue;
      }

      if (rxBuffer.length < 3) return;

      currentMsg = {
        expectedLen,
        received: 0,
        payload: new Uint8Array(expectedLen)
      };

      rxBuffer.splice(0, 3);
      debug(`üì• Start payload expectedLen=${expectedLen}`);
      continue;
    }

    /* --- READ PAYLOAD BYTES --- */
    const need = currentMsg.expectedLen - currentMsg.received;
    const take = Math.min(need, rxBuffer.length);

    currentMsg.payload.set(rxBuffer.slice(0, take), currentMsg.received);
    rxBuffer.splice(0, take);
    currentMsg.received += take;

    if (currentMsg.received < currentMsg.expectedLen) {
      // not complete yet, wait for more
      return;
    }

    /* --- FULL PAYLOAD COMPLETED --- */
    const pb = currentMsg.payload;
    const idxLo = pb[0];
    const idxHi = pb[1];
    const payloadIndex = idxLo | (idxHi << 8);

    // ACK ASAP (C# style)
    sendAck(payloadIndex);

    // Then log + throughput
    debug(`‚úî Full payload index=${payloadIndex} bytes=${pb.length}`);
    reportThroughput(pb.length);

    // Save only payload bytes
    fileChunks.push(pb);
    totalBytes += pb.length;
    document.getElementById("byteCount").textContent = totalBytes.toLocaleString();

    document.getElementById("progressFill").style.width =
      Math.min(100, (totalBytes % 200000) / 2000) + "%";

    currentMsg = null;
  }
}

/* ---------------------------------------------------------
   END OF SYNC ‚Üí WRITE BIN
--------------------------------------------------------- */
async function handleEndOfSync() {
  debug("‚úî Sync complete ‚Äì building BIN...");

  keepReading = false;
  stopWatchdog();

  try {
    if (reader) {
      await reader.cancel().catch(() => {});
      reader.releaseLock();
    }
  } catch (e) {
    debug("‚ö†Ô∏è Error while releasing reader in handleEndOfSync: " + e);
  }

  const total = fileChunks.reduce((s, a) => s + a.length, 0);
  const merged = new Uint8Array(total);
  let offset = 0;

  for (const chunk of fileChunks) {
    merged.set(chunk, offset);
    offset += chunk.length;
  }

  const blob = new Blob([merged], { type: "application/octet-stream" });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement("a");
  const filename = new Date().toISOString().replace(/[:.]/g, "-") + ".bin";

  a.href = url;
  a.download = filename;
  a.click();

  debug(`üíæ Saved ${filename} (${merged.length} bytes)`);

  document.getElementById("syncBtn").disabled = false;
  document.getElementById("stopBtn").disabled = true;
}

/* ---------------------------------------------------------
   CONNECT
--------------------------------------------------------- */
document.getElementById("connectBtn").onclick = async () => {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });

    writer = port.writable.getWriter();
    document.getElementById("syncBtn").disabled = false;
    debug("‚úî Connected.");
  } catch (err) {
    debug("‚ùå Connect error: " + err);
  }
};

/* ---------------------------------------------------------
   START SYNC
--------------------------------------------------------- */
document.getElementById("syncBtn").onclick = async () => {
  if (!port || !writer) {
    debug("‚ùå No port/writer ‚Äì connect first");
    return;
  }

  keepReading = true;
  rxBuffer = [];
  fileChunks = [];
  totalBytes = 0;
  currentMsg = null;
  lastReplySent = ReplyType.NONE;
  lastRxTime = performance.now();
  readRestartCount = 0;
  throughputAvg = 0;

  document.getElementById("byteCount").textContent = "0";
  document.getElementById("progressFill").style.width = "0%";

  debug("=== SYNC START ===");

  // Start watchdog (C# style DataRequestTimer)
  startWatchdog();

  // Initial ReadDataRequest
  sendReadDataRequest();

  reader = port.readable.getReader();
  document.getElementById("syncBtn").disabled = true;
  document.getElementById("stopBtn").disabled = false;

  while (keepReading) {
    try {
      const { value, done } = await reader.read();

      if (done) {
        debug("‚ö†Ô∏è reader.read() returned done=true ‚Äî attempting restart if still syncing");

        if (!keepReading) {
          break;
        }

        if (readRestartCount < MAX_READ_RESTARTS) {
          readRestartCount++;
          debug(`‚ö†Ô∏è Restarting reader (attempt ${readRestartCount}) and resending ReadDataRequest`);
          try {
            reader.releaseLock();
          } catch (e) {
            debug("‚ö†Ô∏è Error releasing reader on restart: " + e);
          }
          reader = port.readable.getReader();
          sendReadDataRequest();
          continue;
        } else {
          debug("‚ùå Max reader restarts reached ‚Äî aborting sync");
          break;
        }
      }

      if (!value || value.length === 0) {
        debug("‚ö†Ô∏è Empty read");
        continue;
      }

      lastRxTime = performance.now();
      feedBytesIntoPacketizer(value);
    } catch (err) {
      debug("‚ùå Read error: " + err);
      break;
    }
  }

  stopWatchdog();
  debug("‚Ñπ Read loop ended");
};

/* ---------------------------------------------------------
   STOP
--------------------------------------------------------- */
document.getElementById("stopBtn").onclick = () => {
  keepReading = false;
  stopWatchdog();
  debug("‚õî STOP requested by user");
};
</script>

</body>
</html>
