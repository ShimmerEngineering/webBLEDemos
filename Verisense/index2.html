<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Verisense BLE Scan/Select + Stream (Accel @ 51.2Hz)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
    button, select, input { padding: 10px 12px; }
    .card { border: 1px solid #444; border-radius: 12px; padding: 12px; }
    pre { background:#111; color:#ddd; padding:10px; border-radius:12px; overflow:auto; max-height: 320px; }
    small { color:#666; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  </style>
</head>
<body>
  <h2>Verisense Stream (Accel1 / LIS2DW12 @ 51.2 Hz)</h2>
  <small>Must be served over <b>https</b> or <b>http://localhost</b>. Click buttons (user gesture required).</small>

  <div class="card">
    <div class="row">
      <label>Name prefix (optional):</label>
      <input id="namePrefix" placeholder="e.g. VERISENSE" />
    </div>

    <div class="row">
      <button id="btnScan">Scan / Select Device</button>
      <button id="btnRefreshKnown">Refresh Known Devices</button>

      <label>Selected:</label>
      <select id="deviceSelect" style="min-width: 360px;">
        <option value="">(none)</option>
      </select>

      <button id="btnConnect" disabled>Connect (BLE)</button>
      <button id="btnConnectSerial">Connect USB (Serial)</button>
      <button id="btnDisconnect" disabled>Disconnect</button>
    </div>

    <div class="row">
      <button id="btnStart" disabled>Start streaming</button>
      <button id="btnStop" disabled>Stop streaming</button>
	  <button id="btnSync" disabled>Sync logged data (.bin)</button>
      <span id="status">Status: idle</span>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Latest accel sample</h3>
      <div id="latest">—</div>
    </div>

    <div class="card">
      <h3>Log</h3>
      <pre id="log"></pre>
      <div class="row">
        <button id="btnClear">Clear log</button>
      </div>
    </div>
  </div>
<div class="card">
  <h3>Accel plot (X/Y/Z)</h3>
  <canvas id="plot" width="700" height="260" style="width:100%; background:#111; border-radius:12px;"></canvas>
  <small id="plotInfo"></small>
</div>

  <script type="module">
  
  
  
    import { VerisenseBleDevice } from "./verisense.js";
	console.log('helloworld'); // <— add this
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    const latestEl = $("latest");
    const statusEl = $("status");

    const btnScan = $("btnScan");
    const btnRefreshKnown = $("btnRefreshKnown");
    const btnConnect = $("btnConnect");
    const btnDisconnect = $("btnDisconnect");
    const btnConnectSerial = $("btnConnectSerial");
    const btnStart = $("btnStart");
    const btnStop = $("btnStop");
    const btnClear = $("btnClear");

    
    const btnSync = $("btnSync");
const deviceSelect = $("deviceSelect");
    const namePrefixEl = $("namePrefix");
const plotCanvas = $("plot");
const plotInfoEl = $("plotInfo");
const ctx = plotCanvas.getContext("2d");

// rolling buffer (last N seconds)
const PLOT_SECONDS = 8;
let accelHz = 51.2;
let maxPoints = Math.ceil(PLOT_SECONDS * accelHz);

// ring buffers
let ax = new Float32Array(maxPoints);
let ay = new Float32Array(maxPoints);
let az = new Float32Array(maxPoints);
let aWrite = 0;
let aCount = 0;

function resetPlotBuffers(hz = 51.2) {
  accelHz = hz;
  maxPoints = Math.ceil(PLOT_SECONDS * accelHz);
  ax = new Float32Array(maxPoints);
  ay = new Float32Array(maxPoints);
  az = new Float32Array(maxPoints);
  aWrite = 0;
  aCount = 0;
}

function pushAccelSample(cal3) {
  ax[aWrite] = cal3[0];
  ay[aWrite] = cal3[1];
  az[aWrite] = cal3[2];
  aWrite = (aWrite + 1) % maxPoints;
  aCount = Math.min(aCount + 1, maxPoints);
}

function drawSeries(series, minY, maxY, w, h, color) {
  if (aCount < 2) return;
  const span = maxY - minY || 1;

  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  ctx.beginPath();

  for (let i = 0; i < aCount; i++) {
    const idx = (aWrite - aCount + i + maxPoints) % maxPoints;
    const x = (i / (aCount - 1)) * (w - 1);
    const y = h - 1 - ((series[idx] - minY) / span) * (h - 1);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
}

let plotRaf = null;
function requestPlotRedraw() {
  if (plotRaf) return;
  plotRaf = requestAnimationFrame(() => {
    plotRaf = null;

    const w = plotCanvas.width;
    const h = plotCanvas.height;

    // background
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, w, h);

    if (aCount < 2) return;

    // autoscale using all 3 axes
    let minY = Infinity, maxY = -Infinity;
    for (let i = 0; i < aCount; i++) {
      const idx = (aWrite - aCount + i + maxPoints) % maxPoints;
      minY = Math.min(minY, ax[idx], ay[idx], az[idx]);
      maxY = Math.max(maxY, ax[idx], ay[idx], az[idx]);
    }
    // small padding
    const pad = (maxY - minY) * 0.05 || 0.1;
    minY -= pad; maxY += pad;

    // draw a midline
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, h / 2);
    ctx.lineTo(w, h / 2);
    ctx.stroke();

    // plot X/Y/Z
    drawSeries(ax, minY, maxY, w, h, "#4cc9f0"); // X
    drawSeries(ay, minY, maxY, w, h, "#f72585"); // Y
    drawSeries(az, minY, maxY, w, h, "#b8f2e6"); // Z

    if (plotInfoEl) {
      plotInfoEl.textContent = `points: ${aCount}/${maxPoints} | scale: ${minY.toFixed(2)} .. ${maxY.toFixed(2)} m/s²`;
    }
  });
}

    function log(...args) {
      const s = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join(" ");
      logEl.textContent += s + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }
	
	if (!("showSaveFilePicker" in window)) {
	  log("This browser doesn't support saving .bin directly to disk.");
	  log("Use Chrome/Edge over https or http://localhost, or use an in-memory download fallback.");
	}
	
    function setStatus(s) { statusEl.textContent = `Status: ${s}`; }

    // Keep a map of devices we can connect to (authorized via chooser or getDevices)
    const devicesById = new Map(); // id -> BluetoothDevice

    function upsertDeviceOption(dev) {
      if (!dev?.id) return;
      devicesById.set(dev.id, dev);

      let opt = [...deviceSelect.options].find(o => o.value === dev.id);
      if (!opt) {
        opt = document.createElement("option");
        opt.value = dev.id;
        deviceSelect.appendChild(opt);
      }
      opt.textContent = `${dev.name ?? "(unnamed)"}  [${dev.id}]`;
      deviceSelect.value = dev.id;

      btnConnect.disabled = false;
    }

    function getSelectedDevice() {
      const id = deviceSelect.value;
      return id ? devicesById.get(id) : null;
    }

    // Your Verisense instance
    let v = null;
    let accelPackets = 0;

    function configureAccelOnly(dev) {
      // We only decode/display accel1 (sensorId = 2). Actual device-side streaming config is separate.
      dev.accel1.setRange("2G");
      dev.accel1.samplingRateHz = 51.2;

      // Turn off other decoders (optional)
      dev.gyroAccel2.setAccelEnabled(false);
      dev.gyroAccel2.setGyroEnabled(false);
      dev.ppg.setChannels({ red:false, ir:false, green:false, blue:false });
      dev.gsr.setEnabled({ gsr:false, batt:false });
    }

    function renderLatest(pkt) {
      const first = Array.isArray(pkt.decoded) ? pkt.decoded[0] : null;
      if (!first?.cal) {
        latestEl.innerHTML = `<div>packets: ${accelPackets}</div><div>No decoded accel yet</div>`;
        return;
      }
      const cal = first.cal.map(n => n.toFixed(5)).join(", ");
      const t = first.timestamps;
      const ts = t ? `${t.tsMillis.toFixed(1)} ms (plot=${t.systemTsPlotMillis.toFixed(1)})` : "—";

      latestEl.innerHTML = `
        <div><b>Accel1 (sensorId=2)</b></div>
        <div>packets: ${accelPackets}</div>
        <div>tick_u24: ${pkt.tick_u24}</div>
        <div>cal (m/s²): ${cal}</div>
        <div><small>timestamp: ${ts} | crcOk: ${pkt.crcOk ?? "n/a"}</small></div>
      `;
    }

// Wire the *same* event handlers regardless of transport (BLE vs USB serial)
function wireDeviceHandlers(dev) {
  // disconnected handler
  dev.on("disconnected", () => {
    log("disconnected");
    setStatus("disconnected");
    btnDisconnect.disabled = true;
    btnStart.disabled = true;
    btnStop.disabled = true;
    btnConnect.disabled = false;
    btnSync.disabled = true;
  });

  // streaming + plotting handler
  let accelSamples = 0;

  // rolling rate calc
  let t0 = performance.now();
  let p0 = 0, s0 = 0;

  // UI throttle
  let pendingPkt = null;
  let rafId = null;

  function scheduleRender(pkt) {
    pendingPkt = pkt;
    if (rafId) return;
    rafId = requestAnimationFrame(() => {
      rafId = null;
      if (pendingPkt) renderLatest(pendingPkt);
    });
  }

  dev.on("data", (pkt) => {
    if (pkt.sensorId !== 2) return;

    accelPackets++;
    const nSamples = Array.isArray(pkt.decoded) ? pkt.decoded.length : 0;
    accelSamples += nSamples;

    // update rates every ~500ms
    const now = performance.now();
    if (now - t0 >= 500) {
      const dt = (now - t0) / 1000;
      const pps = (accelPackets - p0) / dt;
      const sps = (accelSamples - s0) / dt;
      console.log(`[rate] pps=${pps.toFixed(1)} sps=${sps.toFixed(1)} samples/packet=${(pps > 0 ? (sps / pps) : 0).toFixed(1)}`);

      t0 = now;
      p0 = accelPackets;
      s0 = accelSamples;
    }

    for (const s of (pkt.decoded ?? [])) {
      if (s?.cal) pushAccelSample(s.cal);
    }
    requestPlotRedraw();
    scheduleRender(pkt);
  });

  // Optional: surface your op-config logs to the on-page log too
  dev.on("opConfig", ({ op }) => log("opConfig received", { len: op?.length, head: Array.from(op?.slice?.(0, 16) ?? []) }));
  dev.on("opConfigError", (e) => log("opConfigError", e));
}

    // --- UI actions ---

    btnScan.onclick = async () => {
      try {
        // This IS the browser's BLE scan+pick UI (required by Web Bluetooth).
        setStatus("scanning (chooser)...");
        const namePrefix = namePrefixEl.value.trim();

        const opts = namePrefix
          ? { filters: [{ namePrefix }, { services: [VerisenseBleDevice.NUS_SERVICE] }], optionalServices: [VerisenseBleDevice.NUS_SERVICE] }
          : { filters: [{ services: [VerisenseBleDevice.NUS_SERVICE] }], optionalServices: [VerisenseBleDevice.NUS_SERVICE] };

        const dev = await navigator.bluetooth.requestDevice(opts);
        upsertDeviceOption(dev);
        log("authorized device:", { name: dev.name, id: dev.id });
        setStatus("device selected");
      } catch (e) {
        log("scan/select error:", String(e?.message ?? e));
        setStatus("idle");
      }
    };

    btnRefreshKnown.onclick = async () => {
      try {
        if (!navigator.bluetooth.getDevices) {
          log("getDevices() not supported in this browser yet.");
          return;
        }
        const known = await navigator.bluetooth.getDevices();
        log(`known devices: ${known.length}`);
        for (const dev of known) upsertDeviceOption(dev);
      } catch (e) {
        log("refresh known error:", String(e?.message ?? e));
      }
    };

    deviceSelect.onchange = () => {
      btnConnect.disabled = !getSelectedDevice();
    };

    btnConnect.onclick = async () => {
	
  try {
    const dev = getSelectedDevice();
    if (!dev) throw new Error("No device selected");

    // Fresh instance each connect
    v = new VerisenseBleDevice({
      hardwareIdentifier: "VERISENSE_PULSE_PLUS",
      stripStreamCrc: true,
      verifyStreamCrc: false
    });
    configureAccelOnly(v);

    // (re)wire listeners (BLE and USB serial use the same handlers)
    wireDeviceHandlers(v);

setStatus("connecting...");
    accelPackets = 0;
    latestEl.textContent = "—";

    // IMPORTANT: call the class connect() now
    await v.connect({ device: dev });

    log("connected:", { name: dev.name, id: dev.id });

    setStatus("connected");
    btnDisconnect.disabled = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    btnConnect.disabled = true;
	btnSync.disabled = false;

  } catch (e) {
    log("connect error:", String(e?.message ?? e));
    console.warn(e);
    setStatus("error");
  }
    };

    // --- USB Serial connect (Web Serial) ---
    btnConnectSerial.onclick = async () => {
      try {
        // Fresh instance (same class; uses connectSerial())
        v = new VerisenseBleDevice({
          hardwareIdentifier: "VERISENSE_PULSE_PLUS",
          stripStreamCrc: true,
          verifyStreamCrc: false
        });
        configureAccelOnly(v);

        // (re)wire listeners (BLE and USB serial use the same handlers)
        wireDeviceHandlers(v);

        // Reuse your data handler (already defined in BLE connect handler)
        // If you want separate counters per transport, reset them here:
        accelPackets = 0;
        latestEl.textContent = "—";

        setStatus("connecting (USB serial)...");
        // NOTE: requestPort() needs a user gesture; this click qualifies.
        await v.connectSerial({ baudRate: 115200 });

        log("connected (USB serial)");
        setStatus("connected (USB serial)");
                btnSync.disabled = false;
btnDisconnect.disabled = false;
        btnStart.disabled = false;
        btnStop.disabled = true;
        btnConnect.disabled = false; // BLE connect can remain available
      } catch (e) {
        log("serial connect error:", String(e?.message ?? e));
        console.warn(e);
        setStatus("error");
      }
    };


    btnDisconnect.onclick = async () => {
      try {
        setStatus("disconnecting...");
        await v?.disconnect?.();
        setStatus("disconnected");
        btnDisconnect.disabled = true;
        btnStart.disabled = true;
        btnStop.disabled = true;
        btnConnect.disabled = false;
		btnSync.disabled = false;
      } catch (e) {
        log("disconnect error:", String(e?.message ?? e));
        setStatus("error");
      }
    };

    btnStart.onclick = async () => {
      try {
        setStatus("starting stream...");
        await v.startStreaming();
        setStatus("streaming (accel view)");
        btnStart.disabled = true;
        btnStop.disabled = false;
		btnSync.disabled = true;
      } catch (e) {
        log("start error:", String(e?.message ?? e));
        setStatus("error");
      }
    };

    btnStop.onclick = async () => {
      try {
        setStatus("stopping stream...");
        await v.stopStreaming();
        setStatus("connected");
        btnStart.disabled = false;
        btnStop.disabled = true;
		btnSync.disabled = false;
      } catch (e) {
        log("stop error:", String(e?.message ?? e));
        setStatus("error");
      }
    };

    btnClear.onclick = () => { logEl.textContent = ""; };
	
	btnSync.onclick = async () => {
  try {
    if (!v) throw new Error("Not connected");

    setStatus("syncing logged data...");
    log("sync: choose output file...");

    const fileHandle = await window.showSaveFilePicker({
      suggestedName: `verisense_${new Date().toISOString().replace(/[:.]/g, "-")}.bin`,
      types: [{
        description: "Verisense binary",
        accept: { "application/octet-stream": [".bin"] }
      }]
    });

    // IMPORTANT: let verisense.js createWritable + write + close
    v.debugSync = true;

    const res = await v.transferLoggedData({
      fileHandle,
      timeoutMs: 5000,
      maxNack: 5,
      maxCrcNack: 5,
      onProgress: (p) => log("sync progress:", p),
    });

    setStatus("sync complete");
    log("sync: complete ✅", res);
  } catch (e) {
    log("sync error:", String(e?.message ?? e));
    console.warn(e);
    setStatus("error");
  }
};


	
  </script>
</body>
</html>
