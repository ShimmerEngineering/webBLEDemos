<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-T26GWN0LJW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-T26GWN0LJW');
</script>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Breakout Game (EMG)</title>
<style>
  body { margin:0; padding:0; background:#000; color:white; font-family:sans-serif; display:block; overflow-y:auto; }
  button { margin:5px; padding:10px 16px; font-size:16px; border-radius:6px; border:none; cursor:pointer; }
  #scanBtn { background:#2196F3; color:white; }
  #connectBtn { background:#4CAF50; color:white; }
  #streamBtn { background:#FFC107; color:black; }
  #disconnectBtn { background:#f44336; color:white; }
  #startBtn { background:#9C27B0; color:white; }
  #consoleOutput {
    background:#000; color:#0f0; padding:10px; margin:10px auto; max-width:480px;
    font-family:monospace; font-size:16px; border:1px solid #0f0; width:90%;
    line-height:1.4em; max-height:calc(1.4em * 12); overflow-y:auto;
  }
  canvas {
    background:#111; border:2px solid #fff; width:100%; max-width:480px; height:auto; max-height:540px;
    display:block; margin:20px auto; box-sizing:border-box;
  }
  #controls { display:flex; flex-wrap:wrap; justify-content:center; align-items:center; gap:10px; margin-top:10px; text-align:center; }
  #controls button, #controls p { margin:5px; }
  #banner { width:100%; max-width:1000px; margin:10px auto 0; background-image:url('banner.png'); background-repeat:no-repeat; background-position:center; background-size:contain; aspect-ratio:3 / 1; }
  #introOverlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:white; display:flex; justify-content:center; align-items:center; z-index:9999; }
  .introContent { max-width:550px; padding:20px; background:#111; border:2px solid white; border-radius:12px; overflow-y:auto; max-height:90vh; }
</style>
</head>
<body>
<div id="introOverlay">
  <div class="introContent">
    <h2>üéÆ EMG Wrist-Controlled Paddle Game</h2>
    <p><strong>Requirements:</strong></p>
    <ul>
      <li><strong>Device:</strong> Shimmer3R (EMG)</li>
      <li><strong>Firmware:</strong> Version ‚â• <code>v1.0.22</code></li>
    </ul>
    <hr>
    <h3>‚ö° EMG Electrode Placement</h3>
    <p>This game uses <strong>wrist extension</strong> and <strong>wrist flexion</strong> to control the paddle. ‚Ä¶</p>
    <a href="example.png" target="_blank" style="color:#0af; text-decoration:underline;">Example</a>
    <a href="break-emg-demo.mp4" target="_blank" style="color:#0af; text-decoration:underline;">üé• Demo Video</a>

    <h4>‚úÖ FLEXION ‚Äî Locate Flexor Muscles</h4>
    <ul><li>üìç <strong>Target:</strong> Flexor carpi radialis / ulnaris</li><li>üîò <strong>Location:</strong> Inner forearm, 2‚Äì3 fingers below elbow</li></ul>
    <ol><li>Sit with palm facing up</li><li>Bend your wrist toward your body</li><li>Feel for the firm bulge and place electrode there</li></ol>

    <h4>‚úÖ EXTENSION ‚Äî Locate Extensor Muscles</h4>
    <ul><li>üìç <strong>Target:</strong> Extensor carpi radialis longus</li><li>üîò <strong>Location:</strong> Outer top of forearm, near elbow</li></ul>
    <ol><li>Rest forearm palm-down</li><li>Lift your hand upward (extend wrist)</li><li>Feel for tightening band and place electrode on belly</li></ol>

    <p style="font-size:14px;color:#ccc;">‚úÖ <strong>Tip:</strong> ‚Ä¶</p>
    <div style="margin-top:10px; display:flex; align-items:center; gap:10px;">
      <input type="checkbox" id="dontShowAgain" />
      <label for="dontShowAgain">Don't show this again</label>
    </div>
    <button id="closeIntroBtn">Got it!</button>
  </div>
</div>

<div id="controls">
  <button id="scanBtn">üîç Scan Bluetooth</button>
  <button id="connectBtn" disabled>‚öôÔ∏è Configure</button>
  <button id="streamBtn" disabled>üì° Start Streaming</button>
  <button id="disconnectBtn" disabled>‚ùå Disconnect</button>
  <button id="showTipBtn">üí° Show Tip</button>
  <p id="deviceName">No device selected</p>
  <div style="text-align:center; margin-top:10px;">
    <label for="onThreshSlider">Activation Threshold: <span id="threshLabel">3</span></label><br>
    <input type="range" id="onThreshSlider" min="1" max="20" step="0.1" value="3" style="width:300px;">
  </div>
  <div style="text-align:center; margin-top:10px;">
    <label for="ballSpeedSlider">Ball Speed: <span id="ballSpeedLabel">175</span></label><br>
    <input type="range" id="ballSpeedSlider" min="50" max="350" step="5" value="175" style="width:300px;">
  </div>
</div>

<div id="consoleWrapper"><pre id="consoleOutput"></pre></div>
<div id="banner"></div>
<div style="text-align:center; margin-top:20px;"><button id="startBtn">‚ñ∂Ô∏è Start Game</button></div>
<div style="text-align:center; margin-top:10px;">
  <input type="checkbox" id="autoRestart" />
  <label for="autoRestart">Auto-restart after Game Over (5s)</label>
</div>

<canvas id="breakout"></canvas>
<div style="text-align:center; color:#0f0; font-family:monospace; font-size:16px;">üìà EMG Signal 1 (brown - red)</div>
<canvas id="emg1Plot" width="480" height="100" style="background:#111; border:1px solid #0f0; display:block; margin:5px auto 20px;"></canvas>
<div style="text-align:center; color:#f0f; font-family:monospace; font-size:16px;">üìà EMG Signal 2 (black - white)</div>
<canvas id="emg2Plot" width="480" height="100" style="background:#111; border:1px solid #0f0; display:block; margin:5px auto 20px;"></canvas>

<!-- ========= NEW: API-BASED SCRIPT ========= -->
<script type="module">
  import { Shimmer3RClient } from '../ShimmerAPI/shimmer3r.js?v=emg2';

  // ======== your existing globals (keep) ========
  const emg1Buffer = new Array(256*5).fill(0);
  const emg2Buffer = new Array(256*5).fill(0);
  let emgIndex = 0;
  let lastPrintedTime = 0;
  let emgPrintCounter = 0;
  let plotIntervalId = null;
  let emg1Active = false;
  let emg2Active = false;
  let lastTime = null;
  let gameOver = false;
  let gameWon = false;

  window.emg1Buffer = emg1Buffer;
  window.emg2Buffer = emg2Buffer;
  window.emgIndex = emgIndex;
  window.emg1Active = emg1Active;
  window.emg2Active = emg2Active;

  // Intro overlay
  window.addEventListener("DOMContentLoaded", () => {
    if (localStorage.getItem("hideIntroOverlay") === "true") {
      document.getElementById("introOverlay").style.display = "none";
    }
  });
  document.getElementById("closeIntroBtn").addEventListener("click", () => {
    const dontShow = document.getElementById("dontShowAgain").checked;
    if (dontShow) localStorage.setItem("hideIntroOverlay", "true");
    document.getElementById("introOverlay").style.display = "none";
  });

  // ======== filters + helpers (keep) ========
  function blackmanWindow(N){const a0=0.42,a1=0.5,a2=0.08;return Array.from({length:N},(_,n)=>a0-a1*Math.cos((2*Math.PI*n)/(N-1))+a2*Math.cos((4*Math.PI*n)/(N-1))); }
  function sinc(x){return x===0?1:Math.sin(Math.PI*x)/(Math.PI*x);}
  function highPassKernel(N,cutoff,sampleRate){const fc=cutoff/sampleRate,mid=Math.floor(N/2),window=blackmanWindow(N),kernel=[];for(let i=0;i<N;i++){const n=i-mid;const low=2*fc*sinc(2*fc*n);const high=(n===0?1:0)-low;kernel[i]=high*window[i];}return kernel;}
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

  const hpKernel = highPassKernel(51, 50, 256);
  const hpKernel2 = highPassKernel(51, 50, 256);
  const firLen = hpKernel.length;
  const emg1FIR = new Array(firLen).fill(0), emg2FIR = new Array(firLen).fill(0);
  let firIndex = 0, firIndex2 = 0;
  const smoothWindow = 5;
  const emg1Smooth = new Array(smoothWindow).fill(0), emg2Smooth = new Array(smoothWindow).fill(0);
  let smoothIndex = 0, smoothIndex2 = 0;

  // Thresholds + sliders
  let onThresh = 3, offThresh = onThresh - 1;
  const slider = document.getElementById("onThreshSlider");
  const label  = document.getElementById("threshLabel");
  slider.addEventListener("input", () => {
    onThresh = parseFloat(slider.value);
    offThresh = onThresh - 1;
    label.textContent = onThresh.toFixed(1);
  });

  // Ball speed slider: keep your logic
  let ballSpeed = 175, speedX = ballSpeed, speedY = -ballSpeed;
  const ballSpeedSlider = document.getElementById("ballSpeedSlider");
  const ballSpeedLabel = document.getElementById("ballSpeedLabel");
  ballSpeedSlider.addEventListener("input", () => {
    ballSpeed = parseInt(ballSpeedSlider.value);
    ballSpeedLabel.textContent = ballSpeed;
    const angle = Math.atan2(speedY, speedX);
    speedX = ballSpeed * Math.cos(angle);
    speedY = ballSpeed * Math.sin(angle);
  });

  function appendToConsole(text){
    const consoleEl = document.getElementById("consoleOutput");
    consoleEl.textContent += text + "\n";
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function drawEMG(canvas, buffer){
    const ctx = canvas.getContext('2d');
    const width = canvas.width, height = canvas.height;
    ctx.clearRect(0,0,width,height);
    const min = Math.min(...buffer), max = Math.max(...buffer), range = max - min || 1;
    ctx.beginPath();
    for (let i=0;i<buffer.length;i++){
      const x = (i / buffer.length) * width;
      const normalized = (buffer[i] - min) / range;
      const y = height - normalized * height;
      ctx.lineTo(x,y);
    }
    ctx.strokeStyle = '#0f0';
    ctx.stroke();
  }

  // ======== NEW: Shimmer3R API wiring ========
  const client = new Shimmer3RClient({ timestampFmt:'u24', debug:false });

  client.onStatus = (msg) => appendToConsole(msg);
  client.onInquiry = (info) => appendToConsole(`Inquiry: ~${(info?.samplingHz ?? 0).toFixed(2)} Hz, channels=${info?.numChannels ?? '?'}`);

  client.onStreamFrame = (oc) => {
    // Expect layout: [TIMESTAMP, STATUS, EMG1(i16), EMG2(i16)] parsed by the API.
    const f = oc.fields;
    if (!f || f.length < 4) return;

    const emg1 = f[f.length - 2]?.value ?? 0;
    const emg2 = f[f.length - 1]?.value ?? 0;

    // --- EMG1: HP FIR (circular) ---
    emg1FIR[firIndex] = emg1;
    let filtered1 = 0;
    for (let i=0;i<hpKernel.length;i++){
      const idx = (firIndex - i + firLen) % firLen;
      filtered1 += emg1FIR[idx] * hpKernel[i];
    }

    // --- EMG2: HP FIR (circular) ---
    emg2FIR[firIndex2] = emg2;
    let filtered2 = 0;
    for (let i=0;i<hpKernel2.length;i++){
      const idx = (firIndex2 - i + firLen) % firLen;
      filtered2 += emg2FIR[idx] * hpKernel2[i];
    }

    firIndex  = (firIndex  + 1) % firLen;
    firIndex2 = (firIndex2 + 1) % firLen;

    // Rectify
    const rect1 = Math.abs(filtered1);
    const rect2 = Math.abs(filtered2);

    // Moving average smoothing
    emg1Smooth[smoothIndex] = rect1;
    emg2Smooth[smoothIndex2] = rect2;
    smoothIndex  = (smoothIndex  + 1) % smoothWindow;
    smoothIndex2 = (smoothIndex2 + 1) % smoothWindow;
    const smoothed1 = emg1Smooth.reduce((a,b)=>a+b,0) / smoothWindow;
    const smoothed2 = emg2Smooth.reduce((a,b)=>a+b,0) / smoothWindow;

    // Hysteresis
    if (!window.emg1Active && smoothed1 >= onThresh) window.emg1Active = true;
    else if (window.emg1Active && smoothed1 < offThresh) window.emg1Active = false;

    if (!window.emg2Active && smoothed2 >= onThresh) window.emg2Active = true;
    else if (window.emg2Active && smoothed2 < offThresh) window.emg2Active = false;

    // Tie-break
    if (window.emg1Active && window.emg2Active){
      if (smoothed1 > smoothed2) window.emg2Active = false;
      else window.emg1Active = false;
    }

    // Buffers for plotting
    window.emg1Buffer[window.emgIndex] = smoothed1;
    window.emg2Buffer[window.emgIndex] = smoothed2;
    window.emgIndex = (window.emgIndex + 1) % window.emg1Buffer.length;

    // Periodic console log
    if (++emgPrintCounter >= 256) {
      appendToConsole(`EMG smoothed | ch1: ${smoothed1.toFixed(2)} | ch2: ${smoothed2.toFixed(2)}`);
      appendToConsole(`EMG active   | ch1: ${window.emg1Active} | ch2: ${window.emg2Active}`);
      emgPrintCounter = 0;
    }
  };

  // ======== Buttons ========
  const scanBtn = document.getElementById("scanBtn");
  const connectBtn = document.getElementById("connectBtn");
  const streamBtn = document.getElementById("streamBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const deviceNameEl = document.getElementById("deviceName");

  // Scan+Connect (single step via API)
  scanBtn.addEventListener("click", async () => {
    try {
      await client.connect();
      deviceNameEl.textContent = `Selected: ${client.device?.name || 'Shimmer3R'}`;
      connectBtn.disabled = false; // already connected
      streamBtn.disabled = false;
      disconnectBtn.disabled = false;

      // Paddle control tick (same as your old setInterval)
      setInterval(() => {
        const now = Date.now();
        if ((now - lastPrintedTime) < 10) return;
        lastPrintedTime = now;

        window.rightPressed = false;
        window.leftPressed  = false;

        if (window.emg1Active && !window.emg2Active)      window.rightPressed = true;
        else if (window.emg2Active && !window.emg1Active) window.leftPressed  = true;
        else if (window.emg1Active && window.emg2Active)  window.rightPressed = true; // choose one
      }, 50);
    } catch (e) {
      appendToConsole(`‚ùå Connect failed: ${e.message || e}`);
    }
  });

  // (Optional) Connect button ‚Äî second-chance connect
  connectBtn.addEventListener("click", async () => {
    try {
	  await client.setSamplingRate(256); // [0x05,0x80,0x00]
      await sleep(200);

      await client.setSensors(0x100000); // [0x08, 0x00, 0x00, 0x10] -> EMG1+EMG2 mask
      await sleep(200);

	  await client.enableEMG();

      await client.inquiry();     // parse channel schema
      deviceNameEl.textContent = `Selected: ${client.device?.name || 'Shimmer3R'}`;
      streamBtn.disabled = false; disconnectBtn.disabled = false;
    } catch (e) {
      appendToConsole(`‚ùå Connect failed: ${e.message || e}`);
    }
  });

  // Configure + stream via API
  streamBtn.addEventListener("click", async () => {
    try {
      // Match your previous commands:

      await client.startStreaming();

      appendToConsole("üì° Streaming started");
      if (!plotIntervalId) {
        plotIntervalId = setInterval(() => {
          drawEMG(document.getElementById("emg1Plot"), window.emg1Buffer);
          drawEMG(document.getElementById("emg2Plot"), window.emg2Buffer);
        }, 33);
      }
    } catch (e) {
      appendToConsole(`‚ùå Stream failed: ${e.message || e}`);
    }
  });

  // Disconnect
  document.getElementById("disconnectBtn").addEventListener("click", async () => {
    try { await client.disconnect(); }
    finally {
      appendToConsole("üîå Disconnected");
      deviceNameEl.textContent = "No device selected";
      streamBtn.disabled = true;
      disconnectBtn.disabled = true;

      if (plotIntervalId) { clearInterval(plotIntervalId); plotIntervalId = null; }
      window.leftPressed = false;
      window.rightPressed = false;
    }
  });

  // ======== Game (unchanged except vars hook) ========
  const canvas = document.getElementById("breakout");
  const ctx = canvas.getContext("2d");
  function resizeCanvas(){
    const maxWidth=480, maxHeight=540;
    const scale=Math.min(window.innerWidth/maxWidth, window.innerHeight/maxHeight);
    canvas.width=maxWidth; canvas.height=maxHeight;
    canvas.style.width=`${maxWidth*scale}px`; canvas.style.height=`${maxHeight*scale}px`;
  }
  resizeCanvas(); window.addEventListener('resize', resizeCanvas);

  const paddleHeight=10;
  const paddleWidth=75*1.25;
  let paddleX=(canvas.width - paddleWidth)/2;

  const ballRadius=8;
  let x=canvas.width/2; let y=canvas.height-30;
  let animationId=null;

  const brickRowCount=5, brickColumnCount=6, brickWidth=60, brickHeight=20, brickPadding=10, brickOffsetTop=30, brickOffsetLeft=30;
  let rightPressed=false, leftPressed=false;
  window.rightPressed = rightPressed; window.leftPressed = leftPressed;

  const bricks=[];
  for(let c=0;c<brickColumnCount;c++){ bricks[c]=[]; for(let r=0;r<brickRowCount;r++){ bricks[c][r]={x:0,y:0,status:1}; } }

  document.addEventListener("keydown", e => { if (e.key==="ArrowRight") window.rightPressed=true; else if (e.key==="ArrowLeft") window.leftPressed=true; });
  document.addEventListener("keyup", e => { if (e.key==="ArrowRight") window.rightPressed=false; else if (e.key==="ArrowLeft") window.leftPressed=false; });

  canvas.addEventListener("touchstart", e => {
    const touchX=e.touches[0].clientX;
    if (touchX < canvas.width/2){ window.leftPressed=true; window.rightPressed=false; }
    else { window.rightPressed=true; window.leftPressed=false; }
    e.preventDefault();
  });
  canvas.addEventListener("touchend", ()=>{ window.leftPressed=false; window.rightPressed=false; });

  function collisionDetection(){
    for(let c=0;c<brickColumnCount;c++){
      for(let r=0;r<brickRowCount;r++){
        const b=bricks[c][r];
        if (b.status===1){
          if (x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight){
            speedY = -speedY; b.status=0;
          }
        }
      }
    }
  }
  function checkWin(){
    for(let c=0;c<brickColumnCount;c++){ for(let r=0;r<brickRowCount;r++){ if (bricks[c][r].status===1) return false; } }
    return true;
  }
  function drawBall(){ ctx.beginPath(); ctx.arc(x,y,ballRadius,0,Math.PI*2); ctx.fillStyle="#f00"; ctx.fill(); ctx.closePath(); }
  function drawPaddle(){ ctx.beginPath(); ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle="#00f"; ctx.fill(); ctx.closePath(); }
  function drawBricks(){
    for(let c=0;c<brickColumnCount;c++){
      for(let r=0;r<brickRowCount;r++){
        if (bricks[c][r].status===1){
          const brickX=c*(brickWidth+brickPadding)+brickOffsetLeft;
          const brickY=r*(brickHeight+brickPadding)+brickOffsetTop;
          bricks[c][r].x=brickX; bricks[c][r].y=brickY;
          ctx.beginPath(); ctx.rect(brickX,brickY,brickWidth,brickHeight); ctx.fillStyle="#0f0"; ctx.fill(); ctx.closePath();
        }
      }
    }
  }
  function startGame(){
    x=canvas.width/2; y=canvas.height-30; paddleX=(canvas.width - paddleWidth)/2;
    lastTime=null; speedX=ballSpeed; speedY=-ballSpeed;
    cancelAnimationFrame(animationId); animationId=requestAnimationFrame(draw);
    gameOver=false; gameWon=false;
    for(let c=0;c<brickColumnCount;c++){ for(let r=0;r<brickRowCount;r++){ bricks[c][r].status=1; } }
  }
  function draw(timestamp){
    if (!lastTime) lastTime = timestamp;
    const dt=(timestamp - lastTime)/1000; lastTime=timestamp;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBricks(); drawBall(); drawPaddle(); collisionDetection();

    if (!gameWon && checkWin()){
      gameWon = true; alert("üéâ You Win! You can still move the paddle. Press Start Game to restart.");
    }

    if (x + speedX*dt > canvas.width - ballRadius || x + speedX*dt < ballRadius) speedX = -speedX;
    if (y + speedY*dt < ballRadius) speedY = -speedY;
    else if (y + speedY*dt > canvas.height - ballRadius){
      if (x > paddleX && x < paddleX + paddleWidth) speedY = -speedY;
      else if (!gameOver){
        gameOver = true;
        if (document.getElementById("autoRestart").checked){
          showCustomAlert("Game Over! Game will restart in 5 seconds", 4500);
          setTimeout(()=>{ if (!gameOver && !gameWon) return; startGame(); }, 5000);
        } else {
          showCustomAlert("Game Over! You can still move the paddle. Press Start Game to restart.", 5000);
        }
      }
    }

    const moveSpeed = 350;
    if (window.rightPressed && paddleX < canvas.width - paddleWidth) paddleX += moveSpeed*dt;
    else if (window.leftPressed && paddleX > 0) paddleX -= moveSpeed*dt;

    if (!gameOver && !gameWon){ x += speedX*dt; y += speedY*dt; }

    animationId=requestAnimationFrame(draw);
  }
  document.getElementById("startBtn").addEventListener("click", startGame);
  document.getElementById("showTipBtn").addEventListener("click", () => {
    document.getElementById("introOverlay").style.display="flex";
    localStorage.removeItem("hideIntroOverlay");
  });
  function showCustomAlert(message, duration=3000){
    const el=document.getElementById("customAlert"); el.textContent=message; el.style.display="block";
    setTimeout(()=>{ el.style.display="none"; }, duration);
  }
  window.drawEMG = drawEMG; // used by plot interval
</script>

<div id="customAlert" style="
  display:none; position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
  background:#222; color:#fff; padding:16px 24px; border:2px solid #f00; border-radius:10px;
  font-size:16px; z-index:9999; text-align:center;">
  Game Over! You can still move the paddle. Press Start Game to restart.
</div>
</body>
</html>
